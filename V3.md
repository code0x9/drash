# Dev guide to V3

This is the guide to be used to migrate to V3. It shows some API and how the
new Drash core will work.

This can, in the future be adapted to tutorials, especially changing from v1 to
v3, or as a migration guide.

## Table of Contents

- [Controller](#controller)
- [ControllerProxy](#controller-proxy)
- [HandlerProxy](#handler-proxy)
- [Extending Drash](#extending-drash)

### Controller

Controllers are kept pretty much the same. The only change it that now they're
responsible for handling own "scope" of _Request_ and _Response_.

In Drash v1, for each _Request_ it created a new _Controller_. This lead to an
increased use of memory and also slower speeds.

How to change migrate?

```typescript
import { Controller, DrashResponse, DrashRequest } from "https://deno.land/x/drash/mod.ts";

class Home extends Controller {
  public uri = ["/", "/home"];

  public async GET(request: DrashRequest) {
    const response = new DrashResponse();
    response.status = 200;
    response.body = "Hello World";
    return response;
  }
}
```

As you can see, not much has changed from v1.

By default, a Controller implements all http methods defined [here](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods), and the
developer is responsible for choosing or not to overwrite the [default](./src/controllers/Controller.ts)
implementation provided by Drash.

### Controller Proxy

Controller Proxy is a new thing in Drash v3. It's a pattern that allows someone
to decorate a Controller, adding new behaviour, changing it, and more!

This is similar to the classic `middleware` one might know from other http
frameworks and even Drash v1. The only problem with it, it's in the name...

Here's a definition of Middleware: [Wikipedia](https://en.wikipedia.org/wiki/Middleware)

So, how do we do it?

```typescript
import {
  Controller,
  ControllerProxy,
  DrashResponse,
  DrashRequest,
} from "https://deno.land/x/drash/mod.ts";

class Home extends Controller {
  public uri = ["/", "/home"];

  public async GET(request: DrashRequest) {
    const response = new DrashResponse();
    response.status = 200;
    response.body = "Hello World";
    return response;
  }
}

class MethodLogger extends ControllerProxy {
  public async GET(request: DrashRequest) {
    console.log("I can do whatever before the handler");
    const response = await super.GET(request);
    console.log("I can do whatever after the handler");
    return response;
  }
}
```

Easy, right? This drops the need of `experimentalDecorators` set to `true` in
the `tsconfig.json`, which drops the need of `tsconfig.json` at all in Deno!

The Controller Proxy has a direct correlation to the method level middleware from
v1, but without the extra config step.

### Handler Proxy

Just like the [ControllerProxy](#controller-proxy), the Handler Proxy is
responsible for extending the Handler to be easier to code. This is a feature
that also has a mapping to v1. Where [ControllerProxy](#controller-proxy) is
directly related to method level middleware, the Handler Proxy can be
associated to the class level middleware from v1. Except that, once again, it
drops extra configuration and gives the power to the developer!

Let's see how we do it!

```typescript
import {
  Controller,
  HandlerProxy,
  DrashResponse,
  DrashRequest,
} from "https://deno.land/x/drash/mod.ts";

class ClassLogger extends HandlerProxy {
  public async handle(request: DrashRequest) {
    console.log("I'm about to be called before the Controller scope!");
    const response = await super.handle(request);
    console.log("I'm about to be called after the Controller scope!");
    return response;
  }
}
```

### Extending Drash

So how do we extend Drash? Well, I envisioned 2 ways of doing it, and the dev
chooses the one which better fits it's needs. Essentially, a good 3rd party for
Drash would implement ControllerProxy and HandlerProxy.

In the next lines I'll show how to extend Drash the correct way. I'm going to
port [Paladin](https://github.com/drashland/deno-drash-middleware/tree/master/paladin) to work in this new version of Drash. Only ReferrerPolicy, just to show.

By default, we should always go from the more specific, to the more general
implementation. That is, ControllerProxy > HandlerProxy. Why? Because you have
more granular support.

```typescript
// ReferrerPolicy.ts
export type ReferrerPolicy =
  | ""
  | "no-referrer"
  | "no-referrer-when-downgrade"
  | "same-origin"
  | "origin"
  | "strict-origin"
  | "origin-when-cross-origin"
  | "strict-origin-when-cross-origin"
  | "unsafe-url";
```

```typescript
// PaladinControllerProxy.ts
import {
  IController,
  DrashRequest,
  DrashResponse,
  ControllerProxy
} from "drash/mod.ts";

import type { ReferrerPolicy } from "ReferrerPolicy.ts";

export class PaladinControllerProxy extends ControllerProxy {
  private referrerPolicy: ReferrerPolicy;
  public constructor(original: IController, referrerPolicy: ReferrerPolicy) {
    super(original);
    this.referrerPolicy = referrerPolicy;
  }
  // Now we overwrite the endpoints methods
  public async CONNECT(request: DrashRequest) {
    const response = await super.CONNECT(request);
    if (!response.headers) {
      response.headers = new Headers();
    }
    response.headers.set("Referrer-Policy", this.referrerPolicy);
    return this.execute(request, super.CONNECT(request));
  }
  // Let's not copy and paste this to every method and instead create a helper method
  public DELETE(request: DrashRequest) {
    return this.execute(request, super.CONNECT(request));
  }

  public GET(request: DrashRequest) {
    return this.execute(request, super.CONNECT(request));
  }

  public HEAD(request: DrashRequest) {
    return this.execute(request, super.CONNECT(request));
  }

  public OPTIONS(request: DrashRequest) {
    return this.execute(request, super.CONNECT(request));
  }

  public PATCH(request: DrashRequest) {
    return this.execute(request, super.CONNECT(request));
  }

  public POST(request: DrashRequest) {
    return this.execute(request, super.CONNECT(request));
  }

  public PUT(request: DrashRequest) {
    return this.execute(request, super.CONNECT(request));
  }

  public TRACE(request: DrashRequest) {
    return this.execute(request, super.CONNECT(request));
  }

  private async execute(request: DrashRequest, responsePromise: Promise<DrashResponse>) {
    const response = await responsePromise;
    if (!response.headers) {
      response.headers = new Headers();
    }
    response.headers.set("Referrer-Policy", this.referrerPolicy);
    return response;
  }
}
```

```typescript
// PaladinHandlerProxy.ts
import {
  IHandler,
  DrashRequest,
  DrashResponse,
  HandlerProxy
} from "drash/mod.ts";

import type { ReferrerPolicy } from "ReferrerPolicy.ts";

export class PaladingHandlerProxy extends HandlerProxy {
  private referrerPolicy: ReferrerPolicy;

  public constructor(original: IHandler, referrerPolicy: ReferrerPolicy) {
    super(original);
    this.referrerPolicy = referrerPolicy;
  }

  public async handle(request: DrashRequest) {
    const response = await super.handle(request);
    if (!response.headers) {
      response.headers = new Headers();
    }
    response.headers.set("Referrer-Policy", this.referrerPolicy);
    return response;
  }
}
```

```typescript
// mod.ts
export { PaladinControllerProxy } from "PaladinControllerProxy.ts";
export { PaladinHandlerProxy } from "PaladinHandlerProxy.ts";
```

So, this is done and dusted! We have a Proxy that works at method level, or at
class level!

And how does the final dev use this? Easy peasy lemon squisy!

```typescript

```
