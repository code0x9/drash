# Dev guide to V2

This is the guide to be used to migrate to V2. It shows some API and how the
new Drash core will work.

This can, in the future be adapted to tutorials, especially changing from v1 to
v2, or as a migration guide.

## Table of Contents

- [Resource](#resource)
- [ResourceProxy](#resource-proxy)
- [HandlerProxy](#handler-proxy)

### Resource

Resources are kept pretty much the same. The only change it that now they're
responsible for handling own "scope" of _Request_ and _Response_.

In Drash v1, for each _Request_ it created a new _Resource_. This lead to an
increased use of memory and also slower speeds.

How to change migrate?

```typescript
import { Resource, Response, Request } from "https://deno.land/x/drash/mod.ts";

class Home extends Resource {
  public uri = ["/", "/home"];

  public async GET(request: Request) {
    const response = new Response();
    response.status = 200;
    response.body = "Hello World";
    return response;
  }
}
```

As you can see, not much has changed from v1.

By default, a Resource implements all http methods defined [here](https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods), and the
developer is responsible for choosing or not to overwrite the default
implementation provided by Drash.

### Resource Proxy

Resource Proxy is a new thing in Drash v2. It's a pattern that allows someone
to decorate a Resource, adding new behaviour, changing it, and more!

This is similar to the classic `middleware` one might know from other http
frameworks and even Drash v1. The only problem with the it, it's in the name...

Here's a definition of Middleware: [Wikipedia](https://en.wikipedia.org/wiki/Middleware)

So, how do we do it?

```typescript
import {
  Resource,
  ResourceProxy,
  Response,
  Request,
} from "https://deno.land/x/drash/mod.ts";

class Home extends Resource {
  public uri = ["/", "/home"];

  public async GET(request: Request) {
    const response = new Response();
    response.status = 200;
    response.body = "Hello World";
    return response;
  }
}

class MethodLogger extends ResourceProxy {
  public async GET(request: Request) {
    console.log("I can do whatever before the handler");
    const response = await super.GET(request);
    console.log("I can do whatever after the handler");
    return response;
  }
}
```

Easy, right? This drops the need of `experimentalDecorators` set to `true` in
the `tsconfig.json`, which drops the need of `tsconfig.json` at all in Deno!

The Resource Proxy has a direct correlation to the method level middleware from
v1, but without the extra config step.

### Handler Proxy

Just like the [ResourceProxy](#resource-proxy), the Handler Proxy is
responsible for extending the Handler to be easier to code. This is a feature
that also has a mapping to v1. Where [ResourceProxy](#resource-proxy) is
directly related to method level middleware, the Handler Proxy can be
associated to the class level middleware from v1. Except that, once again, it
drops extra configuration and gives the power to the developer!

Let's see how we do it!

```typescript
import {
  Resource,
  HandlerProxy,
  Response,
  Request,
} from "https://deno.land/x/drash/mod.ts";

class ClassLogger extends HandlerProxy {
  public async handle(request: Request) {
    console.log("I'm about to be called before the Resource scope!");
    const response = await super.handle(request);
    console.log("I'm about to be called after the Resource scope!");
    return response;
  }
}
```
